# SPA 구성

- SPA의 특징은 라우팅이 서버에서 수행되지 않고 프런트엔드에서 실행된다.
- 클라이언트 측 구성 위에서 빌드되지만, HTMl 태그를 명시적으로 언급하지 않고, 다른 스크립트만 가져온다.
- 미니 어플리케이션의 수명 주기를 처리하기 위해 웹 컴포넌트에 의존하는 대신 사용자 지정 로더 스크립트가 사용된다.
- 각 마이크로 프런트엔드는 독립적인 SPA를 보여준다. 항상 활성 상태로 모든 네비게이션을 포착하는 대신 각 마이크로 프런트엔드는 특정 조건이 충족될때만 SPA를 활성화한다.(특정 URL에서 특정 상태나 예상되는 사용자 액션에 이르기까지 모든것)

## 장단점

- SPA 구성을 기반으로 하는 마이크로 프런트엔드 솔류현은 마이크로 프런트엔드 아키텍쳐가 아닌 SPA의 장단점을 공유한다.
- 상호 작요이 부드럽고, 몰입감이 있으나 일반적으로 훨씬 더 많은 리소스가 필요하고, 자비스크립트가 작동해야하므로 초기 로딩 시간과 부피가 커진다.
- 모노리식 기반 SPA에는 훌륭한 디버깅 도구가 있지만 그에 비해 마이크로 프런트엔드 기반은 그렇지 않기 때문에 개발하기도 디버깅하기도 훨씬 더 어렵다.
- 다른 마이크로 프런트엔드 패턴과 달리 SPA 구성은 서버측에서 렌더링하기에 가장 어려운 프레임워크중 하나로 대부분 전자상거래 웹사이트나 신문 웹사이트와 같이 정보가 많은 페이지에는 이 패턴을 배제한다.
- 높은 상호작용을 요구하는 어플리케이션이나 툴에 적합하다.

## 핵심 SPA 셸 구축하기

- SPA의 핵심 피러중 하나는 라우팅이기 때문에 일부 조건에 따라 보여지는 페이지를 결정할 수 있어야 한다.
- 활성화된 마이크로 프런트엔드가 비활성화 되거나 그 반대의 경우 액티베이터가 SPA를 마운트하거나 언마운트 해야한다.
- 대부분의 상태변경은 URl 변경일 뿐이며 URL 변경은 라우팅 엔진에 의해 처리된다.
- SPA 액티베이터에 연결된 프레임워크에 구애받지 않는 라이터를 재공하여 단일 어플리케이션에서 여러 SPA 인스턴스를 오케스트레이션 할 수 있다.

## 의존성 공유

- webpack을 사용하면 externals 필드를 사용하여 공유 라이브러리를 사용할 수 있다.
- ES(EMS) 모듈 시스템을 사용하여 배열을 고수하여 명시적 구성 없이 묵시적으로 사용할 수 있지만 지원하려면 최신 버전의 브라우저가 필요하다.
- SystemJS, import map을 통해 SPA 셸이 여러 방법으로 공유 의존성을 등록할 수 있다.
- 공유 의존성이 셸에 직접 번들로 묶이지 않지만 요청시 SystemJS에 의해 지연 로드되며 마이크로 프런트엔드가 로드될 때 적용된다.
- WMF(webpack module federation)을 사용하여 공유의존성 삭제 등의 문제를 해결할 수 있다. 웹팩 청크를 직접 공유하고 가능한 경우 청크를 추가하거나 제거할 수 있어 연합된 독립 모듈에서 어플리케이션을 구축하기 위한 기반을 제공한다.

## 통신 패턴

### 이벤트 교환

- 이벤트는 느슨하게 결합되고 신뢰성이 꽤 높기 때문에 마이크로 프런트엔드의 가장 중요한 통신패턴은 이벤트의 활용이다.
- 이벤트는 핸들러가 등록되지 않았거다 기본 emitter가 없어도 중단되지 않으며, 시간에 얽매이지 않는다.
- DOM API를 활용해 이벤트 리스너 시스템을 사용할 수 있다.

### 데이터 공유

- window 객체나 공유 의존성 또는 접근 가능한 객체에서 핸들러를 제공하여 공유 정보에 액세스 할 수 있는 중앙 위치를 제공한다.

### 컴포넌트 확장하기

- 가장 중요한 통신 패턴은 기존 컴포넌트가 다른 마이크로 프런트엔드에서 제공하는 더 많은 기능을 이용해 확장할 수 있는 방법을 정의하는 것
- 하나의 마이크로 프런트엔드가 추가적인 가치를 더하기 위해서는 확장 슬롯을 만들 수 있다. (중립 집계 컴포넌트 사용)
- 렌더러 및 렌더링될 때 표시된느 여러 컴포넌트와 함께 작동한다.

## 요약

- 통신 패턴을 적용하여 느슨한 결합을 보장하여 어플리케이션의 규모를 원하는 대로 변경할 수 있다.
- 최종 목표는 항상 통합에 필욯나 최소한의 요구사항만 교환하는것
